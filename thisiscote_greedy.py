# -*- coding: utf-8 -*-
"""thisiscote_Greedy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E6xtrMiT_gDfkSA4weNxsSZYxPNYoBuz

이 글은 나동빈님의 <이것이 코딩테스트다 with 파이썬> 을 읽고 정리한 글입니다.

#그리디(Greedy) 알고리즘
: 현재 상황에서 가장 좋은 선택만을 하는 방법이다.

##거스름 돈 문제
: N원을 거슬러 줄 때 최소 동전의 개수를 구하라.

- "가장 큰 단위의 동전"부터 거슬러 준다.
- 예를 들어 거스름돈이 1400원 이라면, 500원 2개, 100원 4개, 총 6개가 최소 개수일 것 이다.
"""

n =1260
count = 0
coin_types = [500,100,50,10]
for coin in coin_types:
  count += n//coin #몫
  n %= coin
print(count)

"""그리디 알고리즘은 효과적이고 단순하지만 모든 문제에 적용시키는 어렵다.

따라서 해당 문제에 대해서 그리디 알고리즘이 사용가능한 지 따져보아야 한다.

위의 경우와 비슷하게 동전을 예시로 들어보겠다.

만약 **1200**원을 거슬러 줘야 하는 상황이다.

동전의 종류가 **700,600,200,100** 이렇게 있다면

그리디 알고리즘에 의해서 700원 1개, 200원 2개, 100원 1개 이렇게 **4개**가 최소 개수가 된다.

하지만 600원 **2개**로 거슬러 주는 것이 더 적은 개수로 거슬러 줄 수 있다.

따라서 거스름돈 문제 중 그리디 알고리즘으로 해결 가능한 문제는 ***가장 큰 단위의 동전이 항상 작은 단위의 동전들의 배수***여야만 한다.

###큰 수의 법칙

- 다양한 수들로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이라고 하자.

- 단, 배열의 특정 인덱스에 해당하는 수가 연속해서 K번 더해질 수 없다.

- 예를 들어, 2,4,5,4,6 의 배열이 있고 M이 8, K가 3 이라고 하자. 6+6+6+5+6+6+6+5 가 정답이 된다.
"""

#가장 큰 수와 두 번째로 큰 수만 필요하다.
n,m,k = map(int, input().split()) # 공백으로 구분하여 입력받기
data = list(map(int, input().split()))
data.sort()
first = data[n-1]
second = data[n-2]
# 수열 [first,...,first,second] 가 반복되는 횟수 -> m / (k+1)
count = (m / (k+1)) * k + m%(k+1) #가장 큰 수가 반복되는 횟수(끝에 더해준 m%(k+1)은 m이 (k+1)로 나누어 떨어지지 않는 경우 가장 큰 수를 더해주는 것)
result = 0
result += first*count
result += second*(m-count)
print(int(result))



"""### 숫자 카드 게임
- 여러 개의 카드 중 가장 큰 숫자의 카드를 뽑는 게임이다.

- 숫자 카드들이 N X M 형태로 놓여있다.

- 뽑고자 하는 **카드의 행을 선택**한다.

- 그 다음 **선택한 행의 카드 중 가장 숫자가 작은 카드**를 뽑아야 한다.

- 따라서 처음에 카드를 고를 행을 선택할 때, 이후 해당 행에서 가장 작은 카드를 뽑을 것을 고려하여 최종적으로 가장 큰 숫자카드를 뽑을 전략을 세워야 한다.


"""

n, m = map(int, input().split()) #n은 행, m은 열
#열마다 최솟값을 찾은 후, 그 중 최댓값을 고르면 된다.
result=0
for i in range(n):
  data = list(map(int, input().split()))
  min_val = min(data)
  result = max(result, min_val)
print(result)

"""##실전문제

### 1이 될 때까지

- 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.
> 1. N에서 1을 뺀다.
> 2. N을 K로 나눈다.

>> N이 17, K가 4라고 해보자. 17 -> 16 -> 4 -> 1 으로 1이 되기 위해서 최소 3회의 반복이 필요하다.
"""

n, k = map(int, input("n값 k값 을 입력해주세요 ex)17 4 : ").split())
count=0
while True:
  if n%k == 0:
    n /= k
    count += 1
  else:
    n -= 1
    count += 1
  if n == 1:
    break
print(count)